# Evaluation of Yaskawa HC10DTP JBI Files

## TPSi-R1.JBI

**Summary:**
This JBI file defines a macro named `TPSi-R1`. Its primary purpose is to interact with a Fronius TPSi welding power source connected via a fieldbus (likely DeviceNet, EtherNet/IP, or similar based on typical Yaskawa setups). The macro performs the following actions:

1. **Sets Mode Bits:** Configures the welding mode or parameters on the Fronius welder by setting specific digital outputs (`OT#(35)` to `OT#(39)`).
2. **Selects Welding Job:** Takes an integer argument (`IARG#(1)`) representing the desired Fronius welding job number, and sends this number to the welder using `MREG#(183)`.
3. **Checks Welder Readiness:** Verifies if the Fronius power source is ready using digital input `IN#(34)`.
4. **Attempts Reset:** If the welder is not ready, it attempts a reset by toggling digital output `OT#(44)`.
5. **Error Handling:** If the welder remains not ready after the reset attempt, it sets a user alarm (8000: "Stromquelle Nicht Bereit !").

**Evaluation Points:**
1. **Functionality:** The code structure correctly addresses the common tasks of selecting a job and checking readiness for an external welding source.
2. **I/O and Register Usage:** The code relies heavily on specific Digital Inputs/Outputs (`IN#`, `OT#`) and an M-Register (`MREG#`). The correct functioning depends entirely on these being accurately mapped in the robot controller's fieldbus configuration to the corresponding signals on the Fronius TPSi welder.
3. **Potential Issue: Infinite Loop:** The error handling logic for when the welder is not ready (`*Retry` loop) appears flawed.
   * It checks `IN#(34)`.
   * If OFF, it increments `LB000`, toggles `OT#(44)`, checks `IN#(34)` again.
   * If still OFF, it sets alarm 8000.
   * Then, it executes `JUMP *Retry IF LB000>=1`. Since `LB000` is incremented *before* this check, it will *always* be `>= 1` after the first failure.
   * This creates an infinite loop where the alarm is repeatedly set if the welder doesn't become ready immediately after the `OT#(44)` toggle. The robot will likely hang in this state.
4. **Clarity:** While the code has some comments, adding comments explaining the specific function of each I/O point (e.g., `DOUT OT#(36) ON ' Select Weld Schedule Mode`) based on the fieldbus documentation would significantly improve readability and maintainability.

**Recommendations:**
1. **Fix the Retry Loop:** Implement a maximum retry count to prevent the infinite loop.
2. **Verify Fieldbus Mapping:** Crucially, confirm that `IN#(34)`, `OT#(35-39)`, `OT#(44)`, and `MREG#(183)` are correctly configured in the robot's I/O and fieldbus settings to communicate with the Fronius welder as intended.
3. **Enhance Comments:** Add detailed comments explaining the purpose of each I/O signal and register based on the verified mapping.

**Note:** This code is specifically written for a Fronius TPSi welding source and will **not** work directly with an ESAB welding source without modification.

## SHIFT-R1.JBI

**Summary:**
This JBI file defines a macro named `SHIFT-R1`. Its purpose is to receive six numerical arguments representing a desired positional offset (X, Y, Z, Rx, Ry, Rz), convert these values into the robot controller's internal format, store them in a specific Position Variable (`P[111]`), and then activate this offset relative to a specific User Frame (`UF#(15)`) using the `SFTON` (Shift On) command.

**How it Works:**
1. **Define P-Variable Index:** It sets a local byte variable `LB000` to 111. This number is used as the index for the Position Variable (`P[111]`) where the shift data will be stored.
2. **Read Arguments:** It reads six integer arguments (`IARG#(1)` to `IARG#(6)`) passed to the macro and stores them in local real variables (`LR000` to `LR005`). These arguments are expected to represent the desired shift in X, Y, Z, Rx, Ry, and Rz respectively.
3. **Unit Conversion:**
   * It multiplies the first three arguments (presumably X, Y, Z) by 1000. This indicates the input is expected in a unit like meters, and it's being converted to millimeters (the standard internal unit for Yaskawa translation).
   * It multiplies the next three arguments (presumably Rx, Ry, Rz) by 10000. This indicates the input is expected in degrees, and it's being converted to 0.0001 degrees (the standard internal unit for Yaskawa rotation).
4. **Store in P-Variable:** It copies the converted values into local double-precision variables (`LD000` to `LD005`) and then uses the `SETE` (Set Element) command to store these six values into the corresponding elements (1 to 6) of the Position Variable `P[111]`.
5. **Activate Shift:** It uses the `SFTON P[111] UF#(15)` command. This activates the calculated shift stored in `P[111]`. All subsequent robot movements will be offset by this amount relative to the coordinate system defined by User Frame 15. The shift remains active until explicitly turned off (e.g., with `SFTOF`).

**Evaluation Points:**
1. **Functionality:** The code correctly implements the logic for receiving external shift values, converting them to the required internal format, and activating the shift using `SFTON`.
2. **Hardcoding:**
   * The Position Variable `P[111]` is hardcoded via `LB000`. This means the macro always uses `P[111]`. If multiple independent shifts were needed, this macro couldn't be used directly without modification or careful management of `P[111]`. Consider passing the P-variable index as an argument for more flexibility.
   * The User Frame `UF#(15)` is hardcoded. The shift is always applied relative to this frame. This might be the intended design, but limits flexibility if shifts relative to other frames are needed. Consider passing the User Frame number as an argument.
3. **Variable Types:**
   * Using `LR` (Real) variables to receive `IARG` (Integer) arguments is functional but potentially less precise if the inputs are guaranteed to be integers. Using `LI` might be slightly cleaner.
   * The intermediate step of copying `LR` values to `LD` variables before using `SETE` appears redundant. `SETE` can typically work directly with `LR` variables containing the correctly scaled values. This adds unnecessary lines of code.
4. **Clarity:** Comments are present but could be more explicit about the expected input units (e.g., "Input X in meters", "Input Rx in degrees").
5. **Error Handling:** There is no validation of the input arguments. Large or invalid inputs could lead to unexpected behavior.

**Overall:** The macro provides a functional way to apply a programmable shift based on input arguments, but its flexibility is limited by the hardcoded P-variable index and User Frame number. The variable usage could be slightly optimized.

## ESAB1JOB.JBI

**Evaluation:**
* **Purpose:** This macro is designed to select a welding job on an ESAB welding source (likely the "ESAB_EDGE" mentioned in comments, connected via fieldbus) and perform basic error checking/resetting.
* **Job Selection:** It takes a job number as an argument (`IARG#(1)`) and sends it to the welder using `MREG#(188)`.
* **Job Validation:** It includes logic to verify if the selected job exists or was accepted by the welder. It checks an input (`IN#(34)`) and reads back the selected job (`MREG#(182)`) to compare with the requested one. It attempts to resend the job number if the initial check fails.
* **Error Handling (Job Selection):** If the job validation fails repeatedly, it sets user alarm 8000 ("WELD JOB DO NOT EXIST"). **Potential Issue:** It then jumps back to the start (`*TOP`), which could create an infinite loop if the job is invalid or communication fails. It should ideally HALT or jump to a specific error state.
* **Error Handling (Welder Status):** It checks several status inputs (`IN#(49)` to `IN#(52)`). If any indicate an error, it attempts a reset by pulsing an output (`OT#(40)`) and waits. If errors persist, it pulses another output (`OT#(4092)`), likely to trigger a higher-level system alarm.
* **Fieldbus Dependency:** The functionality is entirely dependent on the correct mapping of the specific Inputs (`IN#`), Outputs (`OT#`), and M-Registers (`MREG#`) in the robot controller's fieldbus configuration to match the signals of the connected ESAB welder.

**Overall:** This macro handles ESAB job selection and basic error checking. The main concern is the potential infinite loop in the job validation error handling. Verification of the I/O and register mapping against the ESAB integration documentation is crucial.

## HC10_TRQ_SENS_CHECK.JBI

**Evaluation:**
* **Purpose:** This job is designed to perform an automatic check of the robot's torque sensors, likely for a collaborative robot model like the HC10 (indicated by the name and comments). It compares current torque readings against predefined thresholds to determine if a torque sensor calibration is necessary or recommended.
* **Procedure:**
  1. **Initialization:** Defines alarm/message strings (`LS000`-`LS002`) and sets threshold values (`LI000`-`LI011`) for maximum allowed torque deviation and a lower warning level for each of the six robot axes (S, L, U, R, B, T).
  2. **Positioning:** Moves the robot to a specific predefined check position (`P00000`) using `TOOL 0`. The comments emphasize that this position and the tool data must be correctly set up beforehand.
  3. **Torque Reading:** Reads raw torque data for each axis from specific M-Registers (`MREG#(310)` to `MREG#(315)`).
  4. **Data Processing:** Converts the raw M-Register values into torque units (likely Nm, based on comments). This involves subtracting an offset (10000) and scaling (multiplying by 0.1). It then takes the absolute value.
  5. **Threshold Comparison:** Compares the calculated absolute torque value for each axis against its corresponding maximum threshold (`LI000`-`LI005`) and warning threshold (`LI006`-`LI011`).
  6. **Output:**
     * If any axis exceeds its maximum threshold, it sets a user alarm (`SETUALM 8000`) with a subcode (1-6) indicating the specific axis and displays the "Calibration Necessary" message.
     * If any axis meets or exceeds its warning threshold (but not the maximum), it displays the "Calibration is recommended" message (`MSG LS001`).
     * If all axes are below their respective warning thresholds, it displays the "No calibration required" message (`MSG LS002`).
* **Dependencies:** The job relies heavily on:
  * The accuracy of the predefined check position `P00000`.
  * The accuracy of the `TOOL 0` data.
  * The correct mapping and interpretation of torque values from `MREG#(310)`-`MREG#(315)`.
  * The appropriateness of the hardcoded threshold values (`LI000`-`LI011`).
* **Functionality:** The logic appears sound for performing a basic go/no-go check on torque sensor readings at a static position. It provides clear feedback via alarms or messages.

**Overall:** This is a utility job for checking the health of the robot's torque sensors, crucial for collaborative robot safety and performance. Its effectiveness depends on proper setup (position, tool data) and correct system configuration (M-Register mapping).

## POS-SAVE-SYS.JBI

**Evaluation:**
* **Purpose:** This job appears to be a system-level routine designed to save the robot's current position when triggered by a specific event. The `SY` attribute indicates it's a system job, often run in the background or by specific triggers, not typically executed manually.
* **Trigger:** It waits for a specific system input, `IN#(3984)`, to turn ON. This input likely represents a particular system state or event (e.g., start of a power-down sequence, an interrupt condition).
* **Action:** Once `IN#(3984)` is ON, it executes `GETS PX050 $PX000`. This command reads the robot's current position (represented by the system variable `$PX000`) and stores it into the Position Variable `PX050`.
* **Completion:** It then waits for the trigger signal `IN#(3984)` to turn OFF before ending.
* **Use Case:** This type of job is commonly used for recovery purposes. If an unexpected stop or power loss occurs, the system might trigger `IN#(3984)`. This job saves the last known position into `PX050`. A separate recovery or restart job could then potentially use the position stored in `PX050` to safely move the robot or resume the process.

**Overall:** This is a concise system utility job. Its specific function and importance depend entirely on what system event triggers `IN#(3984)` within the overall robot controller configuration. It serves as a mechanism to capture the robot's state at a critical moment.

## SYS_INT_AVOID_R1.JBI

**Evaluation:**
* **Purpose:** Based on the name ("System Interrupt Avoid") and the code, this job acts as a simple interlock or synchronization point.
* **Action:** It contains a single instruction: `WAIT IN#(4090)=OFF`. This command pauses the execution of the job that called this macro until the specific system input `IN#(4090)` turns OFF.
* **Use Case:** This is typically used to prevent the robot from proceeding with a task until a certain condition is met or cleared. `IN#(4090)` likely represents a system state, an external device status, or a safety signal that must be inactive (OFF) before the robot can continue. For example, it might wait for a safety gate to be closed, a PLC signal indicating readiness, or an interference zone to be clear.
* **Dependency:** The exact function depends entirely on what the system input `IN#(4090)` represents in the overall system configuration and wiring.

**Overall:** This is a very simple but potentially critical macro used for process synchronization or safety interlocking, ensuring a specific condition is met before allowing subsequent operations.

## WEAVING.JBI

**Evaluation:**
* **Purpose:** This macro appears designed to set parameters for a weaving function, commonly used in arc welding applications to control the side-to-side motion of the welding torch.
* **Arguments:** It accepts three integer arguments (`IARG#(1)`, `IARG#(2)`, `IARG#(3)`).
* **Processing:**
  * It reads the arguments into local real variables (`LR000`, `LR001`, `LR002`).
  * It multiplies each value by 10. This scaling suggests the input arguments might represent weaving parameters like amplitude (e.g., in mm) or frequency (e.g., in Hz), and the multiplication converts them to the internal units required by the controller's weaving function (e.g., 0.1mm or 0.1Hz).
  * It stores the resulting scaled values into global double-precision variables `D080`, `D081`, and `D082`.
* **Parameter Storage:** Global D-variables (like `D080`-`D082`) are often used by Yaskawa's specialized functions (like arc welding) to hold configuration parameters. The specific meaning of `D080`, `D081`, and `D082` in the context of weaving would be defined in the documentation for the arc welding software option installed on the controller. For example, they might correspond to weaving amplitude, weaving frequency, and end dwell times.
* **Usage:** This macro only *sets* the parameters. It does not initiate the weaving motion itself. A subsequent instruction in the job that calls this macro (e.g., `ARCON ASF#(...)` or a similar welding command) would read these D-variables and execute the weave pattern accordingly.

**Overall:** This is a straightforward parameter-setting macro for configuring a weaving pattern. Its effectiveness depends on the correct interpretation of the input arguments and the proper use of the corresponding D-variables (`D080`-`D082`) by the subsequent welding instructions in the main robot program. Adding comments to clarify the expected input units and the role of each D-variable would improve maintainability.

## WELD-INTERRUPT.JBI

**Evaluation:**
* **Purpose:** This job appears to be an interrupt service routine, likely triggered when a welding process needs to be paused or stopped abruptly (e.g., due to an external sensor, safety signal, or operator input). The `RJ` attribute suggests it might be used as a parallel task or interrupt job.
* **Actions:**
  1. **Save State (?):** `DIN LB000 OT#(3983)` is syntactically unusual. `DIN` reads *inputs*. This might be intended to read the state of an input that mirrors `OT#(3983)`, or it relies on specific system I/O mapping where an output is readable as an input, or it could be a typo. Assuming it intends to save the current state associated with `OT#(3983)`.
  2. **Signal Interrupt Active:** `DOUT OT#(3982) ON` likely signals to the system or external equipment that the interrupt routine is active.
  3. **Set Output:** `DOUT OT#(3983) ON` sets another output, possibly related to stopping external equipment or indicating a specific interrupt state.
  4. **Retraction Move:** `MOVL P050 V=20.0` performs a linear move to position `P050`. `P050` is defined as a relative move (0, 0, 10mm, 20deg Rx, 0, 0) in the ROBOT frame. This is likely a retraction move to pull the tool away from the workpiece safely. The significant rotation (20 deg Rx) is specific to the application/tool.
  5. **Handshake/Signal:** `PULSE OT#(3984) T=0.20` sends a brief signal, potentially to a PLC or other system.
  6. **Wait for Acknowledgement:** `WAIT IN#(3984)=OFF` waits for a corresponding input signal to go OFF, likely an acknowledgement that the external system has registered the interrupt or that it's safe to proceed/finish.
  7. **Restore State:** `DOUT OT#(3983) LB000` restores the state of `OT#(3983)` based on the value saved at the beginning.
  8. **Delay & Signal End:** `TIMER T=0.50` waits briefly, then `DOUT OT#(3982) OFF` signals the end of the interrupt handling.
* **Dependencies:** Relies heavily on the specific configuration and meaning of system I/O points `OT#(3982)`, `OT#(3983)`, `OT#(3984)`, and `IN#(3984)`, as well as the predefined relative position `P050`.
* **Potential Issues:** The `DIN LB000 OT#(3983)` instruction needs clarification or verification based on the system's I/O configuration.

**Overall:** This job defines a structured sequence for handling a weld interruption: signal, retract, handshake, restore state, and signal completion. Its exact behavior is tied to the specific system I/O definitions.

## Variable Types in Yaskawa INFORM

In the Yaskawa INFORM programming language, `LI` and `LR` refer to different types of local variables used within a job or macro:

1. **LI (Local Integer):**
   * **Stands for:** Local Integer.
   * **Stores:** Whole numbers only (e.g., -10, 0, 5, 12345). They cannot store fractions or decimal values.
   * **Range:** Typically -2147483648 to +2147483647 (for a 32-bit signed integer, common in many Yaskawa controllers).
   * **Use Case:** Used for counting, indexing arrays or variables (like the `LB000` used for `P[LB000]` in `SHIFT-R1.JBI`), storing status codes, representing discrete quantities, or receiving integer arguments (`IARG#`).

2. **LR (Local Real):**
   * **Stands for:** Local Real (also known as floating-point).
   * **Stores:** Numbers that can have a decimal point (e.g., -10.5, 0.0, 3.14159, 123.45). They represent continuous values.
   * **Precision:** Standard single-precision floating-point format (IEEE 754). This means they have a limited number of significant digits and can sometimes introduce very small rounding errors in calculations.
   * **Use Case:** Used for calculations involving measurements, positions (though position data is often stored in dedicated P or PR variables), timer values, or any value where fractional parts are necessary. In `SHIFT-R1.JBI`, `LR` variables were used to receive the arguments and perform the multiplication (scaling) before storing them in the P-variable elements, which inherently handle real numbers for position/orientation data.

**Difference in `SHIFT-R1.JBI` Context:**
In the `SHIFT-R1.JBI` macro, the `GETARG` command was used to read integer arguments (`IARG#`) into `LR` (Local Real) variables.

* `GETARG LR000 IARG#(1)`: Reads the first integer argument passed to the macro and stores it in the *real* variable `LR000`. For example, if `IARG#(1)` is `5`, `LR000` becomes `5.0`.

While you *can* store an integer value in a real variable, using `LI` variables (`GETARG LI000 IARG#(1)`) would be slightly more direct if the input arguments are always intended to be whole numbers *before* the scaling multiplication. However, since the subsequent multiplication (`MUL LR000 1000`) and the final storage in a P-variable element (which holds real-number position data) involve real numbers anyway, using `LR` from the start is perfectly functional.
